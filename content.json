{"pages":[],"posts":[{"title":"AQS(上) 同步队列AQS介绍篇","text":"AQS——锁的底层支持AbstractQueuedSynchronizer抽象同步队列简称AQS，它是实现同步器的基础组件，并发包中锁的底层就是使用AQS实现的。另外，大多数开发者可能永远不会直接使用AQS，但是知道其原理对于架构设计还是很有帮助的。下面看下AQS的类图结构，如图所示。 由该图可以看到，AQS是一个FIFO的双向队列，其内部通过节点head和tail记录队首和队尾元素，队列元素的类型为Node。 Node节点内部参数介绍: thread变量用来存放进入AQS队列里面的线程。 SHARED用来标记该线程是获取资源时被阻塞挂起后放入AQS队列的。 EXCLUSIVE用来标记线程是获取独占资源时被挂起后放入AQS队列的。 waitStatus记录当前线程等待状态，可以为以下几种: CANCELLED(线程被取消了) SIGNAL(线程需要被唤醒) CONDITION(线程在条件队列里面等待) PROPAGATE(释放共享资源时需要通知其他节点) prev记录当前节点的前驱节点。 next记录节点的后继节点。 在AQS中维持了一个单一状态的信息state，可以通过getState、setState、compareAndSetState函数修改其值。其具体哪些类中用到了我们可以看一下。 对于ReentrantLock的实现来说，state可以用来表示当前线程获取锁的可重入次数。 对于读写锁ReentrantReadWriteLock来说，state的高16位表示读状态，也就是获取该读锁的次数，低16位标识获取到写锁的线程的可重入次数。 对于semaphore来说，state用来表示当前可用信号的个数。 对于CountDownlatch来说，state用来表示计数器当前的值。 AQS有个内部类ConditionObject，用来结合锁实现线程同步。ConditionObject可以直接访问AQS对象内部的变量，比如state状态值和AQS队列。ConditionObject是条件变量，每个条件变量对应一个条件队列(单向链表队列)，其用来存放调用条件变量的await方法后被阻塞的线程，如类图所示，这个条件队列的头，尾元素分别为firstWaiter和lastWaiter。 对于AQS来说，线程同步的关键是对状态值state进行操作。根据state是否属于一个线程，操作state的方式分为独占方式和共享方式。 在独占方式下获取和释放资源使用的方法为： void acquire(int arg) void acquireInterruptibly(int art) boolean release(int arg) 在共享方式下获取和释放资源的方法为: void acquireShared(int arg) void acquireSharedInterruptibly(int arg) boolean releaseShared(int arg) 使用独占锁方式获取的资源是与具体线程绑定的，就是说如果一个线程获取到了资源，就会标记是这个线程获取到了，其他线程再尝试操作state获取资源时会发现当前该资源不是自己持有的，就会在获取失败后被阻塞。比如独占锁ReentrantLock的实现，当一个线程获取了ReentrantLock的锁后，在AQS内部会首先使用CAS操作把state状态值从0变为1，然后设置当前锁的持有者为当前线程，当该线程再次获取锁时会发现它就是锁的持有者，则会把状态从1变为2，也就是设置可重入次数，而当另一个线程获取锁时发现不是该锁的持有者就会被放入AQS阻塞队列后挂起。 对应共享方式的资源与具体线程是不相关的，当多个线程去请求资源时通过CAS方式竞争获取资源，当一个线程获取到资源后，另外一个线程再次去获取时如果当前资源还能满足它的需要，则当前线程只需要使用CAS方式获取即可。比如Semaphore信号量，当一个线程通过acquire()方法获取信号量时，会首先看当前信号量个数是否满足需求，不满足则把当前线程放入阻塞队列，如果满足则通过自旋CAS获取信号量。 在独占方式下，获取与释放资源的流程如下： 当一个线程调用acquire(int arg)方法时，会首先使用tryAcquire方法尝试获取资源，具体是设置状态变量state的值，成功则直接返回，失败则将当前线程封装为类型Node.EXCLUSIVE的Node节点后插入到AQS阻塞队列的尾部，并调用LockSupport.park(this)方法挂起自己。 12345public final void acquire(int arg){ if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();} 当一个线程调用release(int arg)方法时会尝试使用tryRelease操作释放资源，这里是设置状态变量state的值，然后调用LockSupport.unpark(thread)方法激活AQS队列里面被阻塞的一个线程(thread)。被激活的线程则使用tryAcquire尝试，看当前状态变量state的值是否能满足自己的需求，满足则该线程被激活，然后继续向下运行，否则还是会被入AQS队列被挂起。 123456789public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false;} 需要注意的是，AQS类并没有提供可用的tryAcquire和tryRelease方法，正如AQS是锁阻塞和同步器的基础框架一样，tryAcquire和tryRelease需要由具体的子类来实现。子类在实现tryAcquire和tryRelease时需要根据场景使用CAS算法尝试修改state状态值，成功则返回true。子类还需要定义，在调用acquire和release方法时state状态值的增减代表什么含义。 比如继承自AQS实现的独占锁ReetrantLock，定义当status为0时表示锁空闲，为1表示锁已经被占用。再重写tryAcquire时，在内部需要使用CAS算法查看当前state是否为0，如果为0则使用CAS设置为1，并设置当前锁的持有者为当前线程，而后返回true，如果CAS失败则返回false。 在共享方式下，获取与释放资源的流程如下: 当线程调用acquireShared(int arg)获取共享资源时，会首先使用 trγAcquireShared 尝试获取资源， 具体是设置状态变量 state 的值，成功则直接返回，失败则将当前线 程封装为类型为 Node.SHARED 的 Node 节点后插入到 AQS 阻塞 队列的尾部，并使用 LockSupport.park(this)方法挂起自己。 1234public final void acquireShared(int arg) { if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);} 当一个线程调用 releaseShared(int arg)时会尝试使用 tryReleaseShared 操作释放资源，这里是设置状态变量state 的值，然后使用 LockSupport.unpark (thread）激活 AQS 队 列里面被阻塞的一个线程 (thread)。被激活的线程则使用 tryReleaseShared 查看当前状态变 量 state 的值是否能满足自己的需要，满足则该线程被撤活，然后继续向下运行，否则还 是会被放入 AQS 队列并被挂起。 1234567public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false;} 同样需要注意的是， AQS 类并没有提供可用的 t可AcquireShared 和 tryRelease Shared 方法，正如 AQS 是锁阻塞和同步器的基础框架一样，tryAcquireShared 和 tryReleaseShared 需要由具体的子类来实现。子类在实现 tryAcquireShared 和 tryReleaseShared 时要根据具体 场景使用CAS算法尝试修改 state 状态值，成功则返回 true否则返回 false。 比如继承自 AQS 实现的读写锁 ReentrantReadWriteLock 里面的读锁在重写 tryAcquireShared 时，首先查看写锁是否被其他线程持有，如果是则直接返回 false，否则使用 CAS 递增 state 的高16位 (在 ReentrantReadWriteLock 中，state 的 高 16 位为获取读锁的次数)。 比如继 承自 AQS 实现 的 读写也Ji ReentrantReadWriteLock 里面的 读锁在重写 t叩ReleaseShared 时，在内部需要使用 CAS 算法把当前 state 值的高 16 位减 1， 然后返回 true，如果 CAS 失败则返回 false。 基于 AQS 实现的锁除了 需要重写上面介绍的方法外，还需要重写 isHeldExclusively 方法，来判断锁是被当前线程独占还是被共享。 另外， 也许你会好奇，独占方式下的 void acquire(int arg）和void acquirelnterruptibly(int arg），与共享方式下的 void acquireShared(int arg）和 void acquireSharedlnterruptibly(int arg), 这两套函数中都有一个带有 Interruptibly 关键字的函数，那么带这个关键字和不带有什么 区别呢？我们来讲讲。 其实不带 Intenuptibly 关键字的方法的意思是不对中断进行响应，也就是线程在调用 不带 Interruptibly 关键字的方法获取资源时或者获取资源失败被挂起时，其他线程中断了 该线程， 那么该线程不会因为被中断而抛出异常，它还是继续获取资源或者被挂起，也就 是说不对中断进行响应，忽略中断。 而带 Interruptibly 关键字的方法要对中断进行l响应，也就是线程在调用带 Interruptibly 关键字的方法获取资源时或者获取资源失败被挂起时，其他线程中断了该线程，那么该线 程会抛出 InterruptedException 异常而返回。 最后，我们来看看如何维护 AQS 提供的队列，主要看入队操作。 入队操作： 当一个线程获取锁失败后该线程会被转换为 Node 节点，然后就会使用 enq(final Node node)方法将该节点插入到 AQS 的阻塞队列。 123456789101112131415private Node enq(final Node node) { for (;;) { Node t = tail; // （1） if (t == null) { // Must initialize if (compareAndSetHead(new Node())) // （2） tail = head; } else { node.prev = t; // （3） if (compareAndSetTail(t, node)) { // （4） t.next = node; return t; } } }} 下面结合代码和节点图(下方图)来讲解入队的过程。 如上代码在第一次循环中， 当要在 AQS 队列尾部插入元素时， AQS 队列状态如下方图中（default）所示。 也就是队列 头、尾节点都指向 null ； 当执行代码 (1 ）后节点 t 指向了尾部节点，这时候队列状态如下方图 中 (I）所示。 这时候 t 为 null ，故执行代码（2 ），使用 CAS 算法设置一个哨兵节点为头节点，如果 CAS 设置成功，则让尾部节点也指向哨兵节点，这时候队列状态如下方图中（II）所示。 到现在为止只插入了一个哨兵节点，还需要插入 node 节点，所以在第二次循环后执 行到代码 (1 ），这时候队列状态如下方图 (III）所示 ； 然后执行代码 (3 ）设置 node 的 前驱节点为尾部节点，这时候队列状态如下方图 中 (IV）所示：然后通过 CAS 算法设置 node 节点为尾部节点， CAS 成功后队列状态如下方图 中 CV ）所示： CAS 成功后再设置原 来的尾部节点的后驱节点为 node 这时候就完成了双向链表的插入，此时队列状态如下方图 中（ VI) 所示。 到这里AQS概述，就结束了，下节说条件变量的支持！ 喜欢关注公众号: 我的博客即将同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=33ptblcpxsis8","link":"/detail/52.html"},{"title":"Atomic包中原子类的使用，以及内部CAS的实现和原理","text":"上篇文章有说过 多线程环境下 进行变量属性 自增操作时会造成线程不安全的情况，也有说到 volatile **关键字，最后也不能保证线程安全，因为多线程情况下 他不能保证原子性,不能保证写操作过程不可以被插队,最后有提到java.util.current.atomic包中的AtomicInteger**类,那么它是如何实现线程安全的呢?，让我们一探究竟! atomc包是java专门提供保证原子性的包，里边提供了基本类型的原子操作类，天生就是保证变量原子性的。 今天我们就借此先来说一下AtomicInteger，其他类型类的方法 实现方式都一样。 先对比一下没有使用前会引发的状况: 可以看到没有达到预想的效果，并且每次产生的结果都不一样，这就是上篇 文章所说到的，没有保证原子性，在执行+1操作时被其他线程插队，导致每次往主内存写入了相同的值。注:加上volatile也是会产生一样的结果！因为volatile不能保证原子性。 接下来我们使用AtomicInteger来试一下： 可以看到，达到了我们预期的效果。 那么他到底是是如何实现的呢？ 我们来一探究竟! 在查看究竟前先讲解一个它的一个方法,以及涉及到的知识点，以便于后边的理解: 先说个点:CAS ==&gt; Compare and Swap ==&gt; 比较且交换 接下来 简单使用以下AtomicInteger提供的一个方法: expert:期望值，即 期望改变的值 update:更改值，即 将期望值更改为什么 这里第一次我期望将初始值1更改为2，操作完成后 我再次期望将1 更改为2，我们看下执行结果: 第一次更改 成功 为 true 值变成了2，第二次执行失败 false 里边值还是2，第二次没有被更改过。这就是所谓的比较交换。 我们看下这个方法里边的实现: this , valueOffset 下边会说是什么意思， expect , update 即是期望值和更改值上边有说 记住compareAndSwapInt()这个方法，CAS实现的 关键方法 我们先将目光转到自增方法getAndIncrement方法上看看底层如何实现: 解释下 这个 方法存在的内容: unsafe: 由于Java方法无法直接访问底层系统，需要通过本地(native)方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。 this: 表示当前AtomicInteger类。 valueOffset: 用一个图片说明，在AtomicInteger类有声明: 最后属性 1 是要增加的数值 这里是1。 让我们点进去再看看: 上边我们有看到 compareAndSwapInt 这个方法我们没有细说，这里说下: 解释下: var1: 操作的对象 var2: 内存偏移量地址 var4:要增加的值 var5: 根据内存偏移量地址获取到的值 (上边提到的期望值) var5 + var4 : 更改为的值 然后这里是个循环，先获取 当前内存偏移量位置 的属性值作为期望值，然后进行修改，如果过程其他线程已经改完了，那么修改返回值为false，则继续循环重新获取期望值，再次进行更改，直到修改成为止才退出循环。 1.根据传入对象和内存偏移量地址 拿取对应位置最新的值，为期望值 2.进行写操作，如果过程被其他线程更改，则期望值就会配对不上就会修改失败，继续循环直到成功。 可能 会有人问 这样操作进行修改过程中不会被打断吗？ 对是的，不会被打断的，上边又说Unsafe类中的方法是可以直接访问计算机内存的，可以跟c语言一样。 这是在网上找的代码，内部在向CPU发送CAS指令时的汇编指令,是一条CPU并发原语，过程是原子的。CAS并发语体现在JAVA语言中就是sun.misc.Unsafe类中的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令，这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。所以执行过程是不会被打断的，是线程安全的。 但是 会引发出来另一个问题切记: ABA问题 什么是ABA： 123class ABA{ int i = 1;} 假设此时有两条线程 操作i这个变量线程1，2 同时启动 进行 CAS 操作，他们读到的期望值都为 1接下来 两个线程执行以下过程: 线程1: 将 1 更改为 2 ，然后再将 2 更改为1 线程2:休息 5秒钟，将 1 更改为2 线程1 肯定比 线程2 先执行完，线程2 执行的时候是可以成功将1 更改为2的，但是有一个问题，在他更改的时候他不知道线程1 已经进行了多次更改，将1变为2又变为了1。就像我桌子上的水被偷喝了，然后喝完又给我接了一杯，而我回来后却不知道已经被他人喝过了被他人占了个便宜。有种偷天换月的意思。 解释完之后给大家上个理论知识点:CAS算法实现一个重要前提需要去除内存中某时刻的数据并立刻比较并替换，那么在这个时间出现时间差类会导致数据变化。 这就是很典型的ABA问题，那么如何解决呢？可以加时间戳，版本号都可以解决:AtomicStampedReference类: 上边初始化了 值为10 版本号为1的一个 AtomicStampedReference类，可以看到同样再调用compareAndSet方法的时候需要传4个值:分别为 期望值，修改值，期望版本号，修改版本号 有了版本号就可以避免CAS出现ABA的问题。 Atomic包里边不只是只有 Integer,Long等基本类型的原子类哦，自定义类同样可以原子操作: 可以通过AtomicReference类来操作 大家可以试试下边代码有时间的话: 总结一下:为什么明明可以在 自增方法添加一个Synchronized关键字就可以解决为什么要通过原子类的CAS来解决。Synchronized的比较笨重在上方例子，没必要杀鸡用牛刀，刚好也可以借助上方例子说一下CAS,他在使用时会将它修饰的代码块给锁住，其他线程不可以访问，会大大降低并发。CAS 则可以大大提升并发，线程都可以同时执行，只不过是修改成功与否的问题了。 当然，这里说CAS也比较多也说一下它的缺点:CAS虽然可以提升并发量，但容易给CPU造成很大的开销，并且也只能保证一个共享变量的原子性，对多个共享变量不能同时原子性。 可以关注下公众号。 如果流量允许的情况下，能不能给公众号留个关注:","link":"/detail/38.html"},{"title":"LongAccumulator类原理探究","text":"LongAccumulator类原理探究LongAdder类时LongAccumulator的一个特例，LongAccumulator比LongAdder的功能更强大。例如下面的构造函数，其中accumulatorFunction是一个双目运算器接口，其根据输入的两个参数返回一个计算值，identity则是LongAccumulator累加器的初始值。 1234567891011public LongAccumulator(LongBinaryOperator accumulatorFunction, long identity) { this.function = accumulatorFunction; base = this.identity = identity;}public interface LongBinaryOperator { // 根据两个参数计算并返回一个值 long applyAsLong(long left, long right);} 上面提到，LongAdder其实是LongAccumulator的一个特例，调用LongAdder就相当于使用下面的方式调用LongAccumulator: 12345678910// LongAdder使用LongAdder longAdder = new LongAdder();// LongAccumulator使用LongAccumulator longAccumulator = new LongAccumulator(new LongBinaryOperator() { @Override public long applyAsLong(long left, long right) { return left + right; }}, 0); LongAccumulator相比于LongAdder，可以为累加器提供非0的初始值，后者只能提供默认的0值。另外，前者还可以指定累加规则，比如不进行累加而进行相乘，只需要在构造LongAccumulator时传入自定义的双目运算器即可，后者则内置累加的规则。 随后我们将目光转向到下面代码，从下面代码我们即可知道LongAccumulator相比于LongAdder的不同在于，在调用casBase时后者传递的是b+x，前者则使用了r=function.applyAsLong(b=base, x)来计算。 1234567891011121314151617181920212223242526// LongAdder 的 add方法public void add(long x) { Cell[] as; long b, v; int m; Cell a; if ((as = cells) != null || !casBase(b = base, b + x)) { boolean uncontended = true; if (as == null || (m = as.length - 1) &lt; 0 || (a = as[getProbe() &amp; m]) == null || !(uncontended = a.cas(v = a.value, v + x))) longAccumulate(x, null, uncontended); }}// LongAccumulator 的 accumulate方法public void accumulate(long x) { Cell[] as; long b, v, r; int m; Cell a; if ((as = cells) != null || (r = function.applyAsLong(b = base, x)) != b &amp;&amp; !casBase(b, r)) { boolean uncontended = true; if (as == null || (m = as.length - 1) &lt; 0 || (a = as[getProbe() &amp; m]) == null || !(uncontended = (r = function.applyAsLong(v = a.value, x)) == v || a.cas(v, r))) longAccumulate(x, function, uncontended); }} 另外，前者在调用longAccumulate时传递的时function，而后者是null。从下面代码可知，当fn为null时就会使用v+x加法来运算，这时候就等价于LongAdder，当fn不等于null时则使用传递的fn函数来计算。 123else if (casBase(v = base, ((fn == null) ? v + x : fn.applyAsLong(v, x)))) break; // Fall back on using base 总结本节简单介绍了LongAccumulator的原理。LongAdder类时LongAccumulator的一个特例，只是后者提供了更强大的功能，让用户自定义累加规则。 喜欢关注公众号:","link":"/detail/50.html"},{"title":"CountDownLatch介绍及使用","text":"CountDownLatch作用阻塞一个或多个线程等待其他线程完成操作。 定义初始化的时候，需要传入一个正数来初始化计数器(0也可以，但这样定义没有实际意义)。有两个方法countDown()用于递减计数器,await()方法阻塞当前线程，直到计数器递减为0。 CountDownLatch通常用于多个线程之间的协调工作。 假设有如下情节: 同时获取5张表的数据并一同返回 为了让cpu更好的得到利用，程序执行效率更高，使用多线程来完成。 看如下代码: 12345678910111213141516171819public class CountDownLatchExample { // 循环次数 private static final int FOR_NUMBER = 5; public static void main(String[] args) { // 查询数据 for (int i = 0; i &lt; FOR_NUMBER; i++) { new Thread(() -&gt; { System.out.println(\"查询第:\\t\" + Thread.currentThread().getName() + \"张表数据完成!\"); }, String.valueOf(i)).start(); } System.out.println(\"查询完毕\"); }} 我们看一下执行结果是否是我们想要的结果。 可以看到，还有数据没查询完成他就体检进行查询完毕的操作了。那如果在实际开发过程中，就等于数据还没处理完成就返回用户数据了。这并不是我们想要的结果。 那么刚才也有说CountDownLatch是阻塞一个或多个线程等待其他线程完成操作，那么我们试一下。 12345678910111213141516171819202122232425262728293031public class CountDownLatchExample { // 循环五次 private static final int FOR_NUMBER = 5; // 实例化定义一个CountDownLatch需要减少的总次数 private static CountDownLatch countDownLatch = new CountDownLatch(5); public static void main(String[] args) { // 查询数据 for (int i = 0; i &lt; FOR_NUMBER; i++) { new Thread(() -&gt; { System.out.println(\"查询第:\\t\" + Thread.currentThread().getName() + \"张表数据完成!\"); // 执行完 查询 然后进行递减操作 每次减1 countDownLatch.countDown(); }, String.valueOf(i)).start(); } try { countDownLatch.await(); // await()方法起到阻塞的作用，直到计数器值等于0 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"查询完毕\"); }} 上边我们定义了一个CountDownLatch里边值写入的是5表明我们总共需要减少的次数，再每次执行完查询操作完成后进行减1操作，最后在执行完毕之前进行await()方法阻塞，计数器为0则才放过往下走。我们看一下就结果是否跟想象的一样。 OKK!非常完美的达到了预期的效果。 总体CountDownLatch的作用以及使用就没有了，很简单，大家可以多多尝试。在开发中用到非常多。 补充: CountDownLatch的await()有重载方法await(long timeout, TimeUnit unit), timeout则是设置最大等待时间，unit则是时间类型，如果超过这个时间程序则将继续执行，不再阻塞。 喜欢关注公众号:","link":"/detail/43.html"},{"title":"LockSupport 工具类使用以及实现原理","text":"JDK中的rt.jar包里面的是个LockSupport是个工具类，它的主要作用是挂起和唤醒线程，该工具类是创建锁和其他同步类的基础。 LockSupport类与每个使用它的线程都会关联一个许可证，在默认情况下调用LockSupport类的方法的线程是不持有许可证的。LockSupport是使用Unsafe类实现的，下面介绍LockSupport中的几个主要函数。 void park()如果调用park方法的线程已经拿到了与LockSupport关联的许可证，则调用LockSupport.park()时会马上返回，否则调用线程会被禁止参与线程的调度，也就是会被阻塞挂起。 如下代码直接在main函数里面调用park方法，最终只会输出begin park!，然后当前线程被挂起，这是因为在默认情况下调用线程是不持有许可证的。 1234567public static void main(String[] args) { System.out.println(\"begin park! \"); LockSupport.park(); System.out.println(\"end park! \");} 在其他线程调用unpark(Thread thread) 方法并且将当前线程作为参数时，调用park方法而被阻塞的线程会返回。另外，如果其他线程调用了阻塞线程的interrupt()方法，设置了中断标志或者被虚假唤醒，则阻塞线程也会返回。所以调用park方法时最好也使用循环条件判断方式。 需要注意的是，因调用park()方法而被阻塞的线程被其他线程中断而返回时并不会抛出InterruptedException异常。 void unpark(Thread thread)方法当一个线程调用unpark时，如果参数thread线程没有持有thread与LockSupport类关联的许可证，则让thread线程持有。如果thread之前因调用park()而被挂起，则调用unpark后，该线程会被唤醒。如果thread之前没有调用park，则调用unpark方法后，再调用park方法，则会立即返回。修改代码如下。 1234567891011public static void main(String[] args) { System.out.println(\"begin park! \"); // 使用unpark使当前线程获取到许可证 LockSupport.unpark(Thread.currentThread()); // 再次调用park方法 LockSupport.park(); System.out.println(\"end park! \");} 输出结果: 下面再来看一个例子以加深对park和unpark的理解 12345678910111213141516171819202122public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { System.out.println(\"child thread begin park!\"); // 调用park方法，挂起自己 LockSupport.park(); System.out.println(\"child thread unpark!\"); } }); thread.start(); Thread.sleep(1000); System.out.println(\"main thread begin unpark!\"); // 调用unpark方法让thread线程持有许可证，然后park方法返回 LockSupport.unpark(thread);} 输出结果为 上边代码执行过程如下: 首先创建了一个子线程thread，然后子线程启动调用park方法，由于默认情况下子线程没有持有许可证，因而会把自己挂起。 主线程休眠1s是为了让主线程调用unpark方法前让子线程输出child thread begin park!并阻塞 主线程执行unpark方法，参数为创建的子线程thread，这样做的目的是让子线程持有许可证，然后子线程调用park方法就返回了。 park方法返回时不会告诉你因何种原因返回，所以调用者需要根据之前调用park方法的原因，再次检查条件是否满足，如果不满足还需再次调用park方法。 例如，根据调用前后中断状态的对比就可以判断是不是因为被中断才返回的。 为了说明调用park方法后的线程被中断后会返回，我们修改上面的例子代码，删除LockSupport.unpark(thread)，然后添加thread.interrupt()，具体代码如下。 123456789101112131415161718192021222324public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { System.out.println(\"child thread begin park!\"); while (!Thread.currentThread().isInterrupted()){ // 调用park方法，挂起自己，只有被中断才ui退出循环 LockSupport.park(); } System.out.println(\"child thread unpark!\"); } }); thread.start(); Thread.sleep(1000); System.out.println(\"main thread begin unpark!\"); // 中断子线程 thread.interrupt();} 输出结果: 在如上代码中，只有中断子线程，子线程才会运行结束，如果子线程不被中断，即使调用unpark(thread)方法子线程也不会结束。 void parkNanos(long nanos)方法和park方法类似，如果调用park方法的线程已经拿到了与LockSupport关联的许可证，则调用LockSupport.parkNanos(Long nanos)方法后会马上返回。该方法的不同在于，如果没有拿到许可证，则调用线程会被挂起nanos时间后修改为自动返回。 void park(Object blocker)park方法还支持带有blocker参数的方法 void park(Object blocker)方法，当线程在没有持有许可证的情况下调用park方法而被阻塞挂起时，这个blocker对象会被记录到该线程内部。 使用诊断工具可以观察线程被阻塞的原因，诊断工具是通过调用getBlocker(Thread)方法来获取blocker对象的，所以JDK推荐我们使用带有blocker参数的park方法，并且blocker被设置为this，这样当在打印线程堆栈排查问题时就能知道是哪个类被阻塞了。 例如下面的代码。 1234567891011public class TestPark { public void testPark(){ LockSupport.park(); // (1) } public static void main(String[] args) { TestPark testPark = new TestPark(); testPark.testPark(); }} 运行代码后，使用jps查看运行进程号，然后通过jstack命令查看线程堆栈时可以啊看到如下输出结果。 修改代码(1)为LockSupport.park(this) 后运行代码，则使用jstack命令输出结果为: 使用带blocker参数的park方法，线程堆栈可以提供更多有关阻塞对象的信息。 接下来看看内部实现 12345678910public static void park(Object blocker) { // 获取调用线程 Thread t = Thread.currentThread(); // 设置线程的blocker变量 setBlocker(t, blocker); // 挂起线程 UNSAFE.park(false, 0L); // 线程被激活后清除blocker变量，因为一般都是在线程被阻塞时才分析原因 setBlocker(t, null);} Thread类里面有个变量volatile Object parkBlocker，用来存放park方法传递的blocker对象，也就是把blocker变量存放到了调用park方法的线程的成员变量里面。 void parkNanos(Object blocker, long nanos)相比于park(Object blocker)方法多了个超时时间。 void parkUtil(Object blocker, long deadline)它的代码如下: 123456public static void parkUntil(Object blocker, long deadline) { Thread t = Thread.currentThread(); setBlocker(t, blocker); UNSAFE.park(true, deadline); setBlocker(t, null);} 其中参数deadline的时间单位为ms，改时间是从1970年到现在某一时间点的毫秒值。这个方法和park(Object blocker, long nanos)方法的区别是，后则会是从当前算等待nonos秒时间，而前者是指定一个时间点，比如需要等到2019.11.11日11:11:11,则把则会个时间点转化为从1970年到这个时间点的总毫秒数。 最后再看一个例子。 1234567891011121314151617181920212223242526272829public class FIFOMutex { private final AtomicBoolean locked = new AtomicBoolean((false)); private final Queue&lt;Thread&gt; waiters = new ConcurrentLinkedDeque&lt;Thread&gt;(); public void lock(){ boolean wasInterrupted = false; Thread current = Thread.currentThread(); waiters.add(current); // 只有队首的线程可以获取锁(1) while (waiters.peek() != current || !locked.compareAndSet(false, true)){ LockSupport.park(this); if (Thread.interrupted()){ // (2) wasInterrupted = true; } } waiters.remove(); if (wasInterrupted){ // (3) current.interrupt(); } } public void unlock(){ locked.set(false); LockSupport.unpark(waiters.peek()); }} 这是一个先进先出的锁，也就是只有队列的首元素可以获取锁。在代码(1)处，如果当前线程不是队首或者当前锁已经被其他线程获取，则调用park方法挂起自己。 然后在代码(2)处判断，如果park方法是因为被中断而返回，则忽略中断，并且重置中断标志，做个标记，然后再次判断当前线程是不是队首元素或者当前锁是否已经被其他线程获取，如果是则继续调用park方法挂起自己。 然后再代码(3)中，判断标记，如果标记为true则终端该标志，这个怎么理解呢，其实就是其他线程中断了该线程，虽然我对中断信号不感兴趣，忽略它，但是不代表其他线程对该标志不感兴趣，所以要回恢复下。 喜欢关注公众号:","link":"/detail/51.html"},{"title":"LongAdder(下)使用及代码分析","text":"LongAdder代码分析为了解决高并发下多线程对一个变量CAS争夺失败后进行自旋而造成的降低并发性能的问题，LongAdder在内部维护多个Cell元素(一个动态的Cell数组)来分担单个变量进行争夺开销。下面围绕以下话题从源码角度来分析LongAdder的实现！ LongAdder的结构是怎样的？ 当前线程应该访问Cell数组里面哪一个Cell元素？ 如何初始化Cell数组？ Cell数组如何扩容？ 线程访问分配的Cell元素有冲突后如何处理？ 如何保证线程操作被分配的Cell元素的原子性？ 解决问题1，首先看下LongAdder的类结构图，如图所示： 由该图可知，LongAdder继承自Striped64类，在Striped64内部维护着三个变量。 LongAdder的真实值其实是base的值与Cell数组里面所有Cell元素中的value值的累加，base是个基础值，默认为0。 cellsBusy用来实现自旋锁，状态值只有0和1，当创建Cell元素，扩容Cell数组或者初始化Cell数组时，使用CAS操作该变量来保证同时只有一个线程可以进行其中之一的操作。 解决问题6,下面看Cell的构造！ 123456789101112131415161718192021@sun.misc.Contended static final class Cell { volatile long value; Cell(long x) { value = x; } final boolean cas(long cmp, long val) { return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val); } // Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long valueOffset; static { try { UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; ak = Cell.class; valueOffset = UNSAFE.objectFieldOffset (ak.getDeclaredField(\"value\")); } catch (Exception e) { throw new Error(e); } }} 可以看到，Cell的构造很简单，其内部维护了一个被声明为volatile的变量，这里生命为volatile是因为线程操作value变量时没有使用锁，为了保证变量的内存可见性这里将其声明为volatile的。另外cas方法通过CAS操作，保证了当前线程更新时被分配的Cell元素中Value值的原子性。另外，Cell类使用@sun.misc.Contended修饰是为了避免伪共享。 下面先说一说LongAdder常用函数，然后在里边寻找答案。 long sum() 返回当前的值，内部操作是累加所有Cell内部的value值后再累加base。例如下面代码，由于计算总和时没有对Cell数组进行加锁，所以在累加过程中可能有其他线程对Cell中的值进行了修改，也有可能对数组进行了扩容，所以sum返回的值并不是非常准确的，其返回值并不是一个调用sum方法是的原子快照值。 1234567891011public long sum() { Cell[] as = cells; Cell a; long sum = base; if (as != null) { for (int i = 0; i &lt; as.length; ++i) { if ((a = as[i]) != null) sum += a.value; } } return sum;} void reset() 为重置操作，如下代码把base置为0，如果Cell数组有元素，则元素值被重置为0。 12345678910public void reset() { Cell[] as = cells; Cell a; base = 0L; if (as != null) { for (int i = 0; i &lt; as.length; ++i) { if ((a = as[i]) != null) a.value = 0L; } }} long sumThenReset() 是sum的改造版本，如下代码在使用sum累加对应的Cell值后，把当前Cell的值重置为0，base重置为0。这样，当多线程调用该方法时会有问题，比如考虑第一个线程清空Cell的值，则后一个线程调用时累加的都是0值。 1234567891011121314public long sumThenReset() { Cell[] as = cells; Cell a; long sum = base; base = 0L; if (as != null) { for (int i = 0; i &lt; as.length; ++i) { if ((a = as[i]) != null) { sum += a.value; a.value = 0L; } } } return sum;} long longValue()等价于sum() 下面主要看add方法的实现，从这个方法里面就可以找到其他问题的答案。 12345678910111213141516171819public void add(long x) { Cell[] as; long b, v; int m; Cell a; // (1)~~~ if ((as = cells) != null || !casBase(b = base, b + x)) { boolean uncontended = true; // (2)~~~ if (as == null || (m = as.length - 1) &lt; 0 || // (3) ~~~ (a = as[getProbe() &amp; m]) == null || // (4)~~~ !(uncontended = a.cas(v = a.value, v + x))) // (5) longAccumulate(x, null, uncontended); }}final boolean casBase(long cmp, long val) { return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);} 代码(1)首先看cells是否为null，如果为nul则当前在基础变量base上进行累加，这时候就类似AtomicLong的操作。 如果cells不为null或者线程执行代码(1)的CAS操作失败了，则会去执行代码(2)。 代码(2) (3) 决定当前线程应该访问cells数组里面的哪一个Cell元素，如果当前线程映射的元素存在执行代码(4)，使用CAS操作去更新分配的Cell元素的value值，如果当前线程映射元素不存在或者存在但是CAS操作执行失败执行代码(5)。 其实将代码(2) (3) (4) 合起来看就是获取当前线程应该访问的cells数组的Cell元素，然后进行CAS更新操作，只是获取期间如果有些条件不满足则会跳转到代码(5)。执行。另外当前线程应该访问cells数组的哪一个Cell元素是通过getProbe() &amp; m 进行计算的，其中m是当前cells数组元素个数-1，getProbe() 则用于获取当前线程中变量 threadLocalRandomProbe的值，这个值一开始为0，在代码(5) 里面会对其进行初始化。并且当前线程通过分配的Cell元素的cas函数来保证对Cell元素value值更新的原子性，到这里再一次完善了问题6并且回答了问题2。 longAccumulate() 这里重点研究longAccumulate的代码逻辑，这是cells数组被初始化和扩容的地方。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293final void longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended) { // (6) 初始化当前线程的变量threadLocalRandomProde的值 int h; if ((h = getProbe()) == 0) { ThreadLocalRandom.current(); h = getProbe(); wasUncontended = true; } boolean collide = false; for (;;) { Cell[] as; Cell a; int n; long v; if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) { // (7) if ((a = as[(n - 1) &amp; h]) == null) { // (8) if (cellsBusy == 0) { // Try to attach new Cell Cell r = new Cell(x); // Optimistically create if (cellsBusy == 0 &amp;&amp; casCellsBusy()) { boolean created = false; try { // Recheck under lock Cell[] rs; int m, j; if ((rs = cells) != null &amp;&amp; (m = rs.length) &gt; 0 &amp;&amp; rs[j = (m - 1) &amp; h] == null) { rs[j] = r; created = true; } } finally { cellsBusy = 0; } if (created) break; continue; // Slot is now non-empty } } collide = false; } else if (!wasUncontended) // CAS already known to fail wasUncontended = true; // (9) 当前Cell存在，则执行CAS设置 else if (a.cas(v = a.value, ((fn == null) ? v + x : fn.applyAsLong(v, x)))) break; // (10) 当前Cell数组元素个数大于CPU个数 else if (n &gt;= NCPU || cells != as) collide = false; // At max size or stale // (11) 是否有冲突 else if (!collide) collide = true; // (12) 如果当前元素个数没有达到CPU个数并且有冲突则扩容 else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) { try { if (cells == as) { // Expand table unless stale // (12.1) Cell[] rs = new Cell[n &lt;&lt; 1]; for (int i = 0; i &lt; n; ++i) rs[i] = as[i]; cells = rs; } } finally { // (12.2) cellsBusy = 0; } // (12.3) collide = false; continue; // Retry with expanded table } // (13) 为了能够找到一个空闲的Cell，重新计算hash,xorshift算法生成随机数 h = advanceProbe(h); } // (14) 初始化Cell数组 else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) { boolean init = false; try { // Initialize table if (cells == as) { // (14.1) Cell[] rs = new Cell[2]; // (14.2) rs[h &amp; 1] = new Cell(x); cells = rs; init = true; } } finally { // (14.3) cellsBusy = 0; } if (init) break; } else if (casBase(v = base, ((fn == null) ? v + x : fn.applyAsLong(v, x)))) break; // Fall back on using base }} 上面比较复杂，我们只关注问题3，4，5部分。 当每个线程第一次执行到代码(6)时，会初始化当前线程变量threadLocalRandomProde的值，上面也说了，这个变量在计算当前线程被分配到cells数组的哪一个Cell元素时会用到。 问题3 cells数组的初始化是在代码(14) 中进行的，其中cellsBusy是一个标示，为0说明当前cells数组没有在被初始化或者扩容，也没有在新建Cell元素，为1则说明cells数组在被初始化或者扩容，或者当前在创建新的Cell元素，通过CAS操作来进行0或1状态的切换，这里使用casCellsBusy方法。假设当前线程通过CAS设置cellsBusy为1，则当前线程开始初始化操作，那么这时候其他线程就不能进行扩容了。如代码(14.1)初始化cells数组元素个数为2，然后使用h&amp;1计算当前线程应该访问cell数组的哪个位置，也就是当前线程的threadLocalRandomProbe变量&amp;(cells数组元素个数-1),然后标示cells数组已经被初始化了，最后代码(14.3)重置了cellsBusy标记。显然这里没有使用CAS操作，却是线程安全的，原因是cellsBusy是volatile修饰的。这保证了变量的内存可见性，另外此时其他地方的代码没有机会修改cellsBusy的值。在这里初始化的cells数组里面的两个元素的值目前还是null。这里回答了问题3，知道了cells数组如何被初始化的。 问题4 cells数组的扩容实在代码(12)中进行的，对cells扩容是有条件的，也就是代码(10)(11)的条件都不满足的时候。具体就是当前cells的元素个数小于当前机器CPU个数并且当前多个线程访问了cells中同一个元素，从而导致冲突使其中一个线程CAS失败时才会进行扩容操作。这里为何要涉及CPU个数呢？因为只有当每个CPU都运行一个线程时才会使多线程的效果最佳，也就是当cells数组元素个数与CPU个数一致时，每个Cell都使用一个CPU进行处理，这时性能才是最佳的。代码(12)中的扩容操作也是先通过CAS设置cellsBusy为1，然后才能进行扩容。假设CAS成功则执行代码(12.1)将容量扩充为之前的2倍，并复制Cell元素到扩容后数组。另外，扩容后cells数组里面除了包含复制过来的元素外，还包含其他新元素，这些元素值目前还是null。这里就解决了问题4。 在代码(7)(8)中，当前线程调用add方法并根据当前线程的随机数threadLocalRandomProbe和cells元素计算个数计算访问的Cell元素下标，然后如果发现对应下标值为null，则新增一个Cell元素到cells数组，并且将其添加到cells数组之前要竞争设置cellsBusy为1。 问题5 代码(13)对CAS失败的线程重新计算当前线程的随机值threadLocalRandomProbe，以减少下次访问cells元素时的冲突机会。这里回答了问题5。 小结介绍完了JDK1.8中新增的LongAdder原子性操作类，该类通过内部cells数组分担了高并发下多线程同时对一个原子变量进行更新时的竞争两，让多个线程可以同时对cells数组里面的元素进行并行的更新操作。另外，数组元素Cell使用@sun.misc.Contended注解进行修饰，这避免了cells数组内多个原子变量被放入同一个缓存行，也是避免了伪共享，这对性能也是一个提升。 喜欢关注公众号:","link":"/detail/49.html"},{"title":"ThreadLocal(下)继承性问题解决及实现原理","text":"ThreadLocal不支持继承性首先看一个例子 1234567891011121314151617181920212223public class TestThreadLocal { // (1) 创建线程变量 public static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;String&gt;(); public static void main(String[] args) { // (2) 设置线程变量 threadLocal.set(\"hello world\"); // (3) 启动子线程 Thread thread = new Thread(new Runnable() { @Override public void run() { // (4) 子线程输出线程变量的值 System.out.println(\"thread: \" + threadLocal.get()); } }); thread.start(); // (5) 主线程获取并输出threadLocal的值 System.out.println(\"main: \" + threadLocal.get()); }} 输出结果如下: 通过以上例子可以看到，同一个ThreadLocal变量在父线程中设置值后，在子线程是取不到的。根据上节的介绍，这应该是正常现象。因为子线程thread里面调用get方法时当前线程为thread线程，而这里调用set方法设置的变量时main线程，两者是不同线程，自然子线程访问时放回null。那么有没有办法让子线程能访问到父线程中的值，当然是有的哈哈哈！ InheritableThreadLocal为了解决上节提出的问题，InheritableThreadLocal应运而生。InheritableThreadLocal继承自ThreadLocal，其提供了一个特性，就是让子线程可以访问在父线程中设置的本地变量。下面看一下InheritableThreadLocal的代码。 12345678910111213141516public class InheritableThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; { // (1) protected T childValue(T parentValue) { return parentValue; } // (2) ThreadLocalMap getMap(Thread t) { return t.inheritableThreadLocals; } // (3) void createMap(Thread t, T firstValue) { t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue); }} 由上代码可知，InheritableThreadLocal继承自ThreadLocal，并重写了三个方法。由代码 (3) 可知，InheritableThreadLocal重写了createMap方法，那么现在当第一次调用set方法时，创建的是当前线程inheritableThreadLocals变量而不再是threadLocals。由代码 (2) 可知，当调用get方法获取内部的map变量时，获取的是inheritableThreadLocals而不是threadLocals。 综上可知，在InheritableThreadLocal的世界里，变量inheritableThreadLocals替代了threadLocals。 下面我们看一下重写的代码 (1) 何时执行，以及如何让子线程可以访问到父线程的本地变量。这要从创建Thread的代码说去，打开Thread类的默认构造函数，代码如下。 12345678910111213141516171819public Thread(Runnable target) { init(null, target, \"Thread-\" + nextThreadNum(), 0);}private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc) { ····· // (4) 获取当前线程 Thread parent = currentThread(); ····· // (5) 如果父线程的inheritableThreadLocals变量不为null if (parent.inheritableThreadLocals != null) // (6) 设置子线程中的inheritableThreadLocals变量 this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); this.stackSize = stackSize; tid = nextThreadID(); } 如上代码在创建线程时，在构造函数里面会调用init方法。代码 (4) 获取了当前线程(这里指main函数所在的线程，也就是父线程)，然后代码 (5) 判断main函数所在的线程里面的inheritableThreadLocal属性是否为null，前面我们讲了InheritableThreadLocal类的get和set方法操作的都是inheritableThreadLocals，所以这里inheritableThreadLocals变量不为null，因此会执行代码 (6)。下面看一下createInheritedMap的代码。 123static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) { return new ThreadLocalMap(parentMap);} 可以看到，在createInheritedMap内部使用父线程的inheritableThreadLocals变量作为构造函数创建了一个新的ThreadLocalMap变量，然后赋值给了子线程的inheritableThreadLocals变量。限免我们看看在ThreadLocalMap的构造函数内部都做了什么事情。 123456789101112131415161718192021222324private ThreadLocalMap(ThreadLocalMap parentMap) { Entry[] parentTable = parentMap.table; int len = parentTable.length; setThreshold(len); table = new Entry[len]; for (int j = 0; j &lt; len; j++) { Entry e = parentTable[j]; if (e != null) { @SuppressWarnings(\"unchecked\") ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get(); if (key != null) { // (7) 调用重写方法 Object value = key.childValue(e.value); Entry c = new Entry(key, value); int h = key.threadLocalHashCode &amp; (len - 1); while (table[h] != null) h = nextIndex(h, len); table[h] = c; size++; } } }} 在构造函数内部把父线程的inheritableThreadLocals成员变量的值复制到新的ThreadLocalMap对象中，其中代码 (7) 调用了InheritableThreadLocal类重写的代码 (1)。 总结:InheritableThreadLocal 类通过重写代码 (2) 和 (3) 让本地变量保存到了具体线程的inheritableThreadLocals变量里面，那么线程再通过InheritableThreadLocal类实例的set或get方法设置变量时，就会创建当前线程的inheritableThreadLocals变量。当父线程创建子线程时，构造函数会把父线程中inheritableThreadLocals变量里面的本地变量复制一份保存到子线程的inheritableThreadLocals变量里面。 把第一个例子代码的 (1) 修改为 1public static ThreadLocal&lt;String&gt; threadLocal = new InheritableThreadLocal&lt;String&gt;(); 运行结果如下: 可以看到现在可以从子线程正常获取到线程变量的值了。 那么在什么情况下需要子线程可以获取父线程的threadLocal变量呢？还挺多比如，子线程需要拿到存放在threadLocal变量中的用户登录信息，有的中间件需要把统一的id追踪到的整个调用链路记录下来。其实子线程使用父线程中的threadLocal方法由多种方式，比如创建线程时传入父线程中的变量，并将其复制到子线程中，或者在父线程中构造一个map作为参数传递给子线程，但是这些都改变了我们的使用习惯，所以在这些情况下InheritableThreadLocal就显得比较有用了 喜欢关注公众号:","link":"/detail/47.html"},{"title":"LongAdder(上)介绍篇","text":"之前有篇文章讲过AtomicLong通过CAS提供了非阻塞的原子性操作，相比使用阻塞算法的同步器来说它的性能已经很好了，但是JDK开发组并不满足于此。使用AtomicLong时，在高并发下大量线程会同时去竞争更新同一个原子变量，但是由于同时只有一个线程的CAS操作会成功，这就造成了大量线程竞争失败后，会通过无限循环不断进行自旋尝试CAS操作，而这会白白浪费CPU资源。 因此JDK8新增了一个原子性递增或者递减类LongAdder用来克服在高并发下使用AtomicLong的缺点。既然AtomicLong的性能瓶颈是由于多线程同时去竞争一个变量的更新而产生的，那么如果把一个变量分解为多个变量，让同样多的线程去竞争多个资源，是不是就解决了性能问题？是的，LongAdder就是这个思路。下面通过一张的图来理解两者设计的不同之处。 上图为使用AtomicLong时，是多个线程同时竞争一个原子变量。** 上图所示，使用LongAdder时，则是在内部维护多个Cell变量，每个Cell里面有一个初始值为0的long类型变量，这样，在同等并发量的情况下，争夺单个变量更新操作的线程就会减少，这变相地减少了争夺共享资源的并发量。另外，多个线程在争夺同一个Cell原子变量时如果失败了，它并不是在当前Cell变量上一直自旋CAS重试，而是尝试在其他Cell的变量上进行CAS尝试，这个改变增加了当前线程重试CAS成功的可能性。最后在获取LongAdder当前值时，是把所有Cell变量的value值累加后再加上base返回的。 LongAdder维护了一个延迟初始化的原子性更新数组(默认情况下Cell数组是null)和一个基值变量base。由于Cells占用的内存是相对比较大的，所以一开始并不创建它，而是在需要创建时，也就是懒加载。 当一开始判断Cell数组是null并且并发较少时，所有的累加操作都是对base变量进行的。保持Cell数组的大小为2的N次方，在初始化时Cell数组中的Cell元素个数为2，数组里面的变量实体是Cell类型。Cell类型是AtomicLong的一个改进，用来减少缓存的征用，也就是解决伪共享问题。 对于大多数孤立的多个原子操作进行字节填充是浪费的，原因原子性操作都是无规律地分散在内存中的(也就是说多个原子性变量的内存地址不是连续的)，多个原子变量被放入同一个缓存行的可能性很小。但是原子性数组的内存地址是连续的，所对数组内多个元素能经常共享缓存行，因此这里使用@sun.misc.Contended注解对Cell类进行字节填充，这放置了数组中多个元素共享一个缓存行，在性能上是一个提升。 下节将具体使用以及代码分析!!喜欢关注公众号:","link":"/detail/48.html"},{"title":"ThreadLocal(上)介绍及使用篇","text":"出现背景:多线程访问同一个共享变量特别容易出现并发问题，特别是在多个线程需要对一个共享变量进行写入时，为了保证线程安全，一般使用者在访问共享变量时进行适当的同步。如图所示 同步的措施一般是加锁，这就需要使用者对锁有一定的了解，这就显然加重了使用者的负担，那么有没有一种方式可以做到，当创建一个变量后，每个线程对其进行访问的时候访问的是自己线程的变量呢？ThreadLocal他可以，虽然他不是为了解决这个问题出现的。 ThreadLocal介绍:ThreadLocal是JDK包所提供的，它提供了线程本地变量，也就是说你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本，当多个线程进行同时操作时，实际上也是访问的是自己本地内存里面的变量，从而避免了线程安全问题，创建一个ThreadLocal变量后，每个调用线程都会复制一个备份到自己的本地内存，如图所示。 ThreadLocal使用案例:本案例开启两个线程，在每个线程内部设置了本地线程变量，然后调用print函数打印当前本地变量值，打印后调用remove方法删除本地内存变量，代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ThreadLocalExample1 { // (1) 创建ThreadLocal变量 static ThreadLocal&lt;String&gt; localVariable = new ThreadLocal&lt;&gt;(); // (2)print函数 static void print(String str){ // 打印当前线程本地内存中localVariable变量的值 System.out.println(str + \":\" + localVariable.get()); // 2.1 清楚当前线程本地内存变量// localVariable.remove(); } public static void main(String[] args) { // (3) 创建线程one Thread threadOne = new Thread(new Runnable() { @Override public void run() { // 设置threadOne中的本地变量localVariable的值 localVariable.set(\"threadOne local variable\"); // 调用打印函数 print(\"threadOne\"); System.out.println(\"threadOne remove after\" + localVariable.get()); } }); // 创建线程two Thread threadTwo = new Thread(new Runnable() { @Override public void run() { // 设置threadTwo线程中的本地线程变量 localVariable.set(\"threadTwo local variable\"); // 调用打印函数 print(\"threadTwo\"); // 打印本地线程变量 System.out.println(\"threadTwo remove after\" + \":\" + localVariable.get()); } }); // (5)启动线程 threadOne.start(); threadTwo.start(); }} 运行结果如下: 代码(1) 创建了一个ThreadLocal变量。 代码(3)和(4)创建了两个线程 代码(5) 启动两个线程 线程one中通过set方法设置了localvariable的值，这其实设置的就是线程one本地内存中的一个副本，这个副本线程Two是访问不了的，然后调用了print函数，通过get方法获取到了当前线程one本地内存中的localVariable的值。 线程Two的执行与one相似。 打开2.1的注释后，再次运行，看下执行结果： ThreadLocal的基本使用就到这里了，下节说实现原理 喜欢关注公众号:","link":"/detail/45.html"},{"title":"Java并发-读锁&#x2F;写锁","text":"这篇看一下JUC包提供的读写锁(共享锁/独占锁)。 之前我们都知道在一个变量被读或者写数据的时候每次只有一个线程可以执行，那么今天我们来看一下读写锁，读写两不误ReadWriteLock。 这里有两个概念: 独占锁: 指该锁一次只能被一个线程所持有。(ReentrantLock和Synchronized都属于独占锁)。 共享锁: 指该锁可被多个线程所持有。 ReentrantReadWriteLock其读锁是共享锁，共写锁是独占锁。 读锁的共享锁可以保证并发读是非常高效的，读写，写读，写写的过程是互斥的。 直接使用ReentrantReadWriteLock写段代码看一下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class CacheList{ private volatile ArrayList&lt;Long&gt; list = new ArrayList&lt;&gt;(); private ReadWriteLock lock = new ReentrantReadWriteLock(); public void put(Long value) { try { lock.writeLock().lock(); // 获取写锁 System.out.println(Thread.currentThread().getName() + \" \\t 开始写入数据: \\t\" + value); TimeUnit.SECONDS.sleep(2); // 阻塞两秒 this.list.add(value); System.out.println(Thread.currentThread().getName() + \" \\t 写入数据完成\"); lock.writeLock().unlock(); // 释放写锁 }catch (Exception ex) { ex.printStackTrace(); } } public void get() { try { lock.readLock().lock(); // 获取读锁 System.out.println(Thread.currentThread().getName() + \" \\t 开始读取数据\"); TimeUnit.SECONDS.sleep(2); // 阻塞两秒 String collect = this.list.stream().map(String::valueOf).collect(Collectors.joining(\",\")); System.out.println(Thread.currentThread().getName() + \" \\t 读取数据完成: \" + collect); lock.readLock().unlock(); // 释放读锁 } catch (Exception ex) { ex.printStackTrace(); } }}public class ReadWriteLockDemo { public static void main(String[] args) { CacheList cacheMap = new CacheList(); IntStream.range(0, 5) .forEach(i -&gt; new Thread(() -&gt; cacheMap.put(System.currentTimeMillis()), \"写线程:\" + i).start()); IntStream.range(0, 5) .forEach(i -&gt; new Thread(cacheMap::get, \"读线程:\" + i).start()); }} 上方代码运行效果如下: 可以看到运行结果，红色圈住的地方我们可以看到当使用写锁的时候不管是哪个线程进来都会使其他线程在外等待，直到锁被释放才能拥有获取权限。而蓝色部分是使用了读锁，所有线程可以同时获取允许多个线程同时拥有锁。 注: 但是会出现写一个问题，就是写饥饿现象，上方我们是先运行了所有的写线程，读线程是在写线程后执行的，假如读线程的数量大于写线程数量的话，因锁的大概率都被读线程执行了，就会造成一种写饥饿现象，写线程无法满足大量读线程的读操作，因为写线程少的时候会抢不到锁。 然而在JDK1.8新增了一个锁叫做StampedLock锁,他是对ReadWriteLock的改进。 上边也说了ReadWrite锁可能会出现写饥饿，而StampedLock就是为了解决这个问题锁设计的，StampedLock可以选择使用乐观锁或悲观锁。 乐观锁:每次去拿数据的时候，并不是获取锁对象，而是为了判断标记为(stamp)是否又被修改，如果有修改就再去获取读一次。 悲观锁:每次拿数据的时候都去获取锁。 通过乐观锁，当写线程没有写数据的时候，标志位stamp并没有改变，所以即使有再多的读线程读数据，他都可以读取，而无需获取锁，这就不会使得写线程抢不到锁了。 stamp类似一个时间戳的作用，每次写的时候对其+1来改变被操作对象的stamp值。 通过代码来操作下看一看，先写一个出现写饥饿的情况，模拟19个读线程读取数据，1个写线程写数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class CacheList{ private volatile ArrayList&lt;Long&gt; list = new ArrayList&lt;&gt;(); private StampedLock lock = new StampedLock(); public void put(Long value) { long stamped = -1; // 设置标记位 try { stamped = lock.writeLock(); // 获取写锁 System.out.println(Thread.currentThread().getName() + \" \\t 开始写入数据: \\t\" + value); TimeUnit.SECONDS.sleep(2); // 阻塞两秒 this.list.add(value); System.out.println(Thread.currentThread().getName() + \" \\t 写入数据完成\"); }catch (Exception ex) { ex.printStackTrace(); }finally { lock.unlockWrite(stamped); // 释放写锁 } } public void get() { long stamped = -1; // 设置标记位 try { stamped = lock.readLock(); // 获取读锁 --&gt;这里是悲观锁实现 --&gt; stamped重新赋值标记位 System.out.println(Thread.currentThread().getName() + \" \\t 开始读取数据\"); TimeUnit.SECONDS.sleep(2); // 阻塞两秒 String collect = this.list.stream().map(String::valueOf).collect(Collectors.joining(\",\")); System.out.println(Thread.currentThread().getName() + \" \\t 读取数据完成: \" + collect); } catch (Exception ex) { ex.printStackTrace(); }finally { lock.unlockRead(stamped); // 释放读锁 --&gt; 这里我们放入一个标记位 } }}public class ReadWriteLockDemo2 { public static void main(String[] args) { CacheList cacheMap = new CacheList(); IntStream.range(0, 19) .forEach(i -&gt; new Thread(cacheMap::get, \"读线程:\" + i).start()); IntStream.range(0, 1) .forEach(i -&gt; new Thread(() -&gt; cacheMap.put(System.currentTimeMillis()), \"写线程:\" + i).start()); }} 上边使用了StampedLock做了一个读锁悲观锁的实现，模拟了20个线程，假设了写线程因不能及时写入数据造成写饥饿现象。我们看一下运行结果。 可以看到结果，读锁都可以同时获取锁，就算写线程没有写入数据所有读线程还是在抢占锁，使用ReadWriteLock也是会出现同样的现象，写饥饿。 下面我们使用 乐观锁，每次判断标记位是否被修改，如果有被修改就再进行上锁然后重新读取。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class CacheList{ private volatile ArrayList&lt;Long&gt; list = new ArrayList&lt;&gt;(); private StampedLock lock = new StampedLock(); public void put(Long value) { long stamped = -1; // 设置标记位 try { stamped = lock.writeLock(); // 获取写锁 System.out.println(Thread.currentThread().getName() + \" \\t 开始写入数据: \\t\" + value); TimeUnit.SECONDS.sleep(2); // 阻塞两秒 this.list.add(value); System.out.println(Thread.currentThread().getName() + \" \\t 写入数据完成\"); }catch (Exception ex) { ex.printStackTrace(); }finally { lock.unlockWrite(stamped); // 释放写锁 } } public void get() { // 这里使用了乐观锁，每次去判断标记位是否被改变，如果写线程有修改此值会被修改 long stamped = lock.tryOptimisticRead(); try { System.out.println(Thread.currentThread().getName() + \" \\t 开始读取数据\"); TimeUnit.SECONDS.sleep(2); // 阻塞两秒 } catch (Exception ex) { ex.printStackTrace(); } // 读取值 String collect = this.list.stream().map(String::valueOf).collect(Collectors.joining(\",\")); // 判断以下标记位是否被修改，被修改就会返回false，说明有写线程写入了新数据 // 那么重新获取锁并去读取值，否则直接使用上面读取的值 if (!lock.validate(stamped)){ try { stamped = lock.readLock(); collect = this.list.stream().map(String::valueOf).collect(Collectors.joining(\",\")); }catch (Exception ex) { ex.printStackTrace(); }finally { lock.unlockRead(stamped); } } System.out.println(Thread.currentThread().getName() + \" \\t 读取数据完成: \" + collect); }}public class ReadWriteLockDemo2 { public static void main(String[] args) { CacheList cacheMap = new CacheList(); IntStream.range(0, 19) .forEach(i -&gt; new Thread(cacheMap::get, \"读线程:\" + i).start()); IntStream.range(0, 1) .forEach(i -&gt; new Thread(() -&gt; cacheMap.put(System.currentTimeMillis()), \"写线程:\" + i).start()); }} 直接看运行结果: 主要看get方法，get方法开始调用StampedLock的tryOptimisticRead方法来获取标志位stamp，获取乐观锁那块并不是真的去上锁(所以不会阻塞写操作),然后直接去读数据。接着通过validate方法来判断标志位是否被修改了，修改了就在进行获取锁进行读取，没被修改则会返回true直接使用上边获取到的值。 StampedLock解决了在没有新数据写入时，由于过多读操作抢夺锁而使得写操作一直获取不到锁无法写入新数据的问题。 喜欢关注公众号:","link":"/detail/41.html"},{"title":"ThreadLocal(中)实现原理如何做到本地化","text":"ThreadLocal实现原理下面是ThreadLocal相关类的类结构图，如图: 由该图可知，Thread类中有一个threadLocals和一个inheritableThreadLocals，它们都是ThreadLocalMap类型的变量，而ThreadLocalMap是一个定制化的HashMap。在默认情况下，每个线程中的这两个变量都为null，只有当线程第一次调用ThreadLocal的set()或get()方法时才华创建它们。其实每个线程的本地变量不是存放在ThreadLocal实例里面，而是存放在具体线程内存空间中。ThreadLocal就是一个工具壳，它通过set方法把value值放入调用线程的threadLocals里面并存放起来，当调用线程调用它的get方法时，再从当前线程的threadLocals变量里面将其拿出来使用。如果调用线程一直不重质，那么这个本地变量会一直存放在调用线程的threadLocals变量里面，所以当不需要使用本地变量的时候可以通过调用ThreadLocal变量的remove()方法，从当前线程的threadLocals里面删除该本地变量。另外，Thread里面的threadLocals为何被设计为map结构？很明显是因为每个线程可以惯量多个ThreadLocal变量。 下面简单分析ThreadLocal的set，get以及remove方法的实现逻辑。 void set(T value)1234567891011public void set(T value) { // (1) 获取当前线程 Thread t = Thread.currentThread(); // (2) 将当前线程作为key，去查找对应的线程变量，找到则设置 ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else // (3) 第一次调用就创建当前线程对应的HashMap createMap(t, value);} 代码 (1) 首先获取调用线程，然后使用当前线程作为参数调用getMap(t)方法，getMap(Thread t)的代码如下。 123ThreadLocalMap getMap(Thread t) { return t.threadLocals;} 可以看到，getMap(t)的作用时获取线程自己的变量threadLocals，threadLocal变量被绑定到了线程的成员变量上。 如果getMap(t)的返回值不为空，则把value值设置到threadLocals中，也就是把当前变量放入当前线程的内存变量threadLocals中。threadLocals是一个HashMap结构，其中key就是当前ThreadLocal的实例对象引用，value是通过set方法传递值。 如果getMap(t)返回值为空则说明是第一次调用set方法，这时创建当前线程的threadLocals变量。下面来看createMap(t, value)做什么。 123void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue);} 它创建当前线程的threadLocals变量。 T get()12345678910111213141516171819public T get() { // (1) 获取当前线程 Thread t = Thread.currentThread(); // (2) 获取当前线程的threadLocals变量 ThreadLocalMap map = getMap(t); // (3) 如果threadLocals不为null，则返回对应本地变量的值 if (map != null) { ThreadLocalMap.Entity e = map.getEntity(this); if (e != null) { @SuppressWrarnings(\"unchecked\") T result = (T)e.value; return result; } } // (4) threadLocals为空则初始化当前线程的threadLocals成员变量 return setInitialValue(); } 代码 (1) 首先获取当前线程实例，如果当前线程的threadLocals变量不为null，则直接返回当前线程绑定的本地线程变量，负责执行代码 (4) 进行初始化。setInitialValue() 的代码如下。 123456789101112131415161718private T setInitialValue() { // (5) 初始化为null T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); // (6) 如果当前线程的threadLocals不为空 if (map != null) map.set(this, value); else // (7) 如果当前线程的threadLocals变量为空 createMap(t, value); return value;}protected T initialValue() { return null;} 如果当前线程的threadLocals变量不为空，则设置当前线程的本地线程变量值为null，否则调用createMap方法创建当前线程的createMap变量。 void remove()12345public void remove() { ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this);} 以上代码所示，如果当前线程的threadLocals变量不为空，则删除当前线程中指定ThreadLocal实例的本地变量。‘ 总结：在每个线程内部都有一个名为threadLocals的成员变量，该变量的类型为HashMap，其中key为我们定义的ThreadLocal变量的this引用，value则为我们使用set方法设置的值。 每个线程本地变量存放在线程自己的内存变量threadLocals中，如果当前线程一直不消亡，那么这些本地变量会一直存在，所以可能会造成内存溢出，因此使用完毕后要记得调用ThreadLocal的remove方法删除对应线程的threadLocals中的本地变量。 喜欢关注公众号:","link":"/detail/46.html"},{"title":"Volatile关键字介绍及使用","text":"volatile关键字java虚拟机提供的轻量级同步机制 保证可见性 禁止指令重排序 不保证原子性 可见性: 什么叫可见性呢，首先要说一下JAVA虚拟机内存,JAVA虚拟机内存模型规定，所有的变量都放在计算机的主内存当中，主内存是共享内存区域，所有线程都可以访问，而每个线程创建时都会为其创建一个工作内存(可以称之为栈空间),工作内存呢就是每个线程的私有数据区域，所以每个线程创建时也会从主内存进行一个变量副本拷贝，每当修改的时候也是再自己的工作内存中进行修改的，不能直接操作主内存，修改完成之后再对主内存的变量进行重新赋值，因此线程之间无法访问对方的工作内存，线程之间必须通过主内存来完成。 因此 当变量声明了 volatile关键字之后，每当线程进行写操作的时候会立即刷新到主内存中，并且强制其他有缓存过此变量的线程数据清空，并且重新读取最新数据。 原子性: 原子性的意思呢就是一组操作要么成功要么失败的意思，为什么volatile不能保证原子性呢。 看以下代码进行分析: 12345678 class Test{ volatile int i = 0; public void add() { i++; }} 假如此时创建了两条线程，那么他们的工作内存中 i 都是等于0。此时同时进行调用add()方法进行i+1的操作，操作过程为如下: 1. 从主内存获取最新值 2.进行+1操作 3.写回主内存 我们可以看一下通过查看java的汇编字节码中的执行顺序, 通过javap命令看到: 可以看到java编译后的汇编字节码执行顺序一样，先get，再进行add自增，再进行put 写回数据 如果说两个线程同时调用，他们第一步肯定都是获取到的是0，写回主内存的时候线程A 写回1，线程B也是写回1 。因此不能保证原子性，因为他的操作过程是会被打断的。所以有可能我们进行多线程将 1 加到 1000的时候可能会导致结果不正确 会小于 1000； 指令重排序: 这个涉及到的东西有点多，跟计算机进行计算有很大的关系 可以看一下当你运行一段代码大概需要进行的操作 源代码-&gt;编译器优化的重排-&gt;指令并行的重排-&gt;内存系统的重排-&gt;最终执行的指令。 这些排序呢只是为了计算机能够更快的进行一个代码的计算。 1234int a = 1; // 1int b = 3; // 2a = a + 2; // 3 b = b * a + 1; // 4 以上是我们写代码的执行步骤 1 -&gt; 2 -&gt; 3 -&gt; 4 但是经过计算机的排序后有可能会是 2 -&gt; 1 -&gt; 3 -&gt; 4 是不确定的,因此加上了volatile关键字后可以防止进行排序. 有这么三点: 单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。 处理器在进行重排序时必须要考虑指令之间的数据依赖性。 多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程 中使用的变量能否保证一致性是无法确定的，结果无法预测 依赖性呢就是说，上边代码 永远不可能 会是 第4步执行，因为他对变量a有依赖。 总结: volatile呢是一个 轻量级的同步机制，如果我们想要弥补volatile原子性的问题，我们可以给 add()方法加上 *synchronized *关键字或者是加lock 通过加锁 来保证原子性，但是 建议没必要 大材小用，大家可以看一下java提供的 AtomicInteger类，是一个专门提供可以保证原子性的类。可以保证多线程中数据的安全性。 注:后边会更新 为什么 AtomicInteger可以保证原子性，怎么实现。 我会持续每天更新，也可以关注公众号，在公众号内进行查看!","link":"/detail/37.html"},{"title":"线程的通知与等待","text":"Java中的Object类是所有类的父类，鉴于继承机制，Java把所有的类都需的方法放在了Object类里面，其中就包含要说的通知与等待。 1.wait()方法 当一个线程调用一个共享变量的wait()方法时,该调用线程会被阻塞挂起,直到发生下面几件事情之一才返回。 ​ 1.其他线程调用了该共享对象的 notify() *或者 *notifyAll() 方法。 ​ 2.其他线程调用了该线程的 interrupt() 方法，该线程抛出 InterruptedException 异常返回 另外需要注意的是，如果调用 wait() 方法的线程没有事先获取该对象的监视器锁，则调用wait()方法时调用线程会抛出 *IllegalMonitorStateException *异常。 那么一个线程如何才能获取一个共享变量的监视器锁呢? ​ 1.执行synchronized同步代码块时使用该共享变量作为参数。 123synchronized(共享变量){ // doSomething} ​ 2.调用该共享变量的方法，并且该方法使用了 synchronized 修饰。 123synchronized void method(int a, int b){ // doSomething} 另外需要注意的时，一个线程可以从挂起状态变为可以运行的状态(也就是被唤醒)，即使该线程没有被其他线程调用notify(), notifyAll() 方法进行通知，或者被中断，或者等待超时。也就是所谓的虚假唤醒。 虽然虚假唤醒在应用实践中很少发生，但要防患于未然，做法就是不停地去测试该线程被唤醒状态的条件是否满足，不满足则继续等待，也就是说在一个循环中调用wait()方法进行防范。退出循环的条件就是满足了唤醒该线程的条件。 12345synchronized (obj) { while(条件不满足){ obj.wait(); }} 如上代码呢也是经典的调用共享变量wait()方法的实例，首先通过同步块获取obj上面的监视器锁，然后再while 循环内调用obj的wait()方法。 下面从一个简单的生产者和消费者例子来加深下理解。如下面代码所示，其中queue为共享变量，生产者线程在调用queue的wait()方法前，使用synchronized关键字拿到了该共享变量queue的监视器锁，所以调用wait()方法不会抛出 IllegalMonitorStateException 异常。如果当前队列没有空闲容量则会调用wait()方法挂起当前线程，这里使用循环是为了避免上面说的虚假唤醒。假如当前线程被虚假唤醒了，但是队列还是没有空余的容量，那么当前线程还是会调用wait()方法把自己挂起。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class ObjectMethodTest { Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); int MAX_SIZE = 1; // 假设队列长度只有1 ， 只能存放一条数据 public void produce(){ synchronized (queue){ // 队列满则等待队列空间 while (queue.size() == MAX_SIZE) { // 挂起当前线程，并释放通过同步块获取的queue上的锁，让消费者线程可以获取该锁，然后获取队列里面的元素。 try { queue.wait(); System.out.println(\"-----等待消费----\"); } catch (InterruptedException e) { e.printStackTrace(); } } queue.add(\"hahaha\"); queue.notifyAll(); } } public void consume(){ synchronized (queue) { while (queue.size() == 0) { // 挂起当前线程，并释放通过同步块获取的queue上的锁，让消费者线程可以获取该锁，然后获取队列里面的元素。 try { queue.wait(); System.out.println(\"-----等待生产-----\"); } catch (InterruptedException e) { e.printStackTrace(); } } // 消费元素, 并通知唤醒生产者 System.out.println(\"消费成功:\" + queue.poll()); queue.notifyAll(); } } public static void main(String[] args) { ObjectMethodTest objectMethodTest = new ObjectMethodTest(); // 10 个生产线程 for (int i = 0; i &lt; 10; i++) { new Thread(objectMethodTest::produce).start(); } // 10 个消费线程 for (int i = 0; i &lt; 10; i++) { new Thread(objectMethodTest::consume).start(); } }} 在如上代码中，假如生产者线程A首先通过synchronized获取到了queue上的锁，那么后续所有企图生产的线程和消费的线程 都将会在获取该监视器锁的地方被阻塞挂起。线程A获取锁后发现队列已满会调用wait()方法阻塞挂起自己，然后就会释放掉获取到的queue上的锁，防止发生死锁。 另外需要注意的是，当前线程调用共享变量的wait()方法后指挥释放当前共享变量上的锁，如果当前线程还持有其他共享变量的锁，则这些锁是不会被释放的，接下来看例子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class WaitTest { private static volatile Object resourceA = new Object(); private static volatile Object resourceB = new Object(); public static void main(String[] args) throws InterruptedException { // 创建线程 Thread threadA = new Thread(() -&gt; { try { synchronized (resourceA) { System.out.println(\"threadA 获取到resourceA的锁\"); synchronized (resourceB){ System.out.println(\"threadA 获取到 resourceB的锁\"); System.out.println(\"threadA 释放掉 resourceA的锁\"); resourceA.wait(); } } }catch (Exception ex) { ex.printStackTrace(); } }); // 创建线程 Thread threadB = new Thread(() -&gt; { try { Thread.sleep(1000); synchronized (resourceA) { System.out.println(\"threadB 获取到resourceA的锁\"); System.out.println(\"threadB 尝试获取resourceB的锁*****\"); synchronized (resourceB){ System.out.println(\"threadB 获取到 resourceB的锁\"); System.out.println(\"threadB 释放掉 resourceA的锁\"); resourceA.wait(); } } }catch (Exception ex) { ex.printStackTrace(); } }); threadA.start(); threadB.start(); threadA.join(); threadB.join(); }} 如上代码在main方法里 启动了 A,B两个线程，为了让A先获取到锁，这里让线程B休眠了1s，线程A先后获取到了共享变量resourceA和resourceB上的锁，然后调用了resourceA的wait()方法阻塞挂起自己，阻塞自己后线程A释放掉了获取到的resourceA上的锁。 线程B休眠后结束后会先尝试获取resourceA上的锁，如果当前线程A里边还没有调用resourceA的wait()方法阻塞挂起释放掉该锁，那么线程B就会被阻塞，如果线程A释放了resourceA的锁后，线程B就会获取到resourceA上的锁，然后尝试获取resourceB上的锁。由于线程A中没有释放锁，所以导致线程B尝试获取resourceB上的锁时会被阻塞。 以上就证明了当前线程调用共享变量对象的wait()方法时，当前线程只会释放当前共享对象的锁，当前线程持有其他共享对象的监视器锁并不会被释放。 这里再举个例子说明当一个线程调用共享对象的wait()方法被阻塞挂起后，如果其他线程中断了该线程，则该线程会抛出InterruptedException异常返回。 1234567891011121314151617181920212223242526272829public class WaitNotifyInterrupt { static Object obj = new Object(); public static void main(String[] args) throws InterruptedException { Thread testThread = new Thread(() -&gt; { try { System.out.println(\"----begin----\"); // 阻塞当前线程 synchronized (obj) { obj.wait(); } System.out.println(\"---end---\"); } catch (Exception ex) { ex.printStackTrace(); } }); testThread.start(); Thread.sleep(1000); System.out.println(\"开始阻断 testThread\"); testThread.interrupt(); System.out.println(\"阻塞 testThread 完毕\"); }} 如上代码，testThread调用了共享变量obj的wait()方法后阻塞挂起了自己，然后主线程休眠1s后中断了testThread线程，中断后testThread再obj.wait()处抛出了java.lang.InterruptedException 异常而返回并终止。 2.wait(long timeout)方法 该方法相比于wait()方法多了一个超时参数，它的不同之处在于，如果一个线程调用共享变量的该方法挂起后，没有再指定的timeout ms时间内被其他线程调用该共享变量的notify()或者notifyAll()方法唤醒，那么该函数还是因为超时而返回。如果将timeoout设置为0那么则和wait()方法效果一样，因为wait()方法内部就是调用了wait(0)，需要注意的是，如果在调用该方法时，传递了一个负的timeout则会抛出IllegalArgumentException异常。 3.wait(long timeout, int nanos)方法 在内部调用的是wait(long timeout)函数，如下代码只用nanos&gt;0时才使timeout参数递增1。 12345678910111213141516public final void wait(long timeout, int nanos) throws InterruptedException { if (timeout &lt; 0) { throw new IllegalArgumentException(\"timeout value is negative\"); } if (nanos &lt; 0 || nanos &gt; 999999) { throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); } if (nanos &gt; 0) { timeout++; } wait(timeout);} 4.notify()方法 一个线程调用共享对象的notify方法后，会唤醒一个在该共享变量上调用wait系列方法后被阻塞挂起的线程。一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。 此外，被唤醒的线程不能马上从wait方法返回并继续执行，它必须在获取了共享对象的监视器锁后才可以返回，也就是唤醒它的线程释放了共享变量上的监视器锁后，被唤醒的线程也不一定会获取到共享变量的监视器锁，这是因为该线程还需要和其他线程一起竞争该锁，只有该线程竞争到了共享变量的监视器锁后才能继续执行。 类似wait()系列方法，只有当前线程获取到了共享变量的监视器锁后，才可以调用共享变量的notify()方法，否则会抛出 IllegalMonitorStateException异常。 5.notifyAll()方法 不同于在共享变量上调用notify()，会唤醒被阻塞到该共享变量上的一个线程，notifyAll()方法则会唤醒所有在该共享变量由于调用wait()系列方法而被挂起的线程。 下面举个例子来说明notify()和notifyAll()方法具体含义以及一些需要注意的地方。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class NotifyTest { private static volatile Object resourceA = new Object(); public static void main(String[] args) throws InterruptedException { // 创建线程 Thread threadA = new Thread(() -&gt; { // 获取resourceA的共享资源锁 synchronized (resourceA) { System.out.println(\"threadA 获取到 resourceA 的锁\"); try { System.out.println(\"threadA 开始调用resourceA的wait()方法进行阻塞挂起\"); resourceA.wait(); System.out.println(\"threadA 结束等待\"); } catch (Exception ex) { ex.printStackTrace(); } } }); // 创建线程 Thread threadB = new Thread(() -&gt; { synchronized (resourceA) { System.out.println(\"threadB 获取到 resourceA 的锁\"); try { System.out.println(\"threadB 开始调用resourceA的wait()方法进行阻塞挂起\"); resourceA.wait(); System.out.println(\"threadB 结束等待\"); } catch (Exception ex) { ex.printStackTrace(); } } }); // 创建线程 Thread threadC = new Thread(() -&gt; { synchronized (resourceA) { System.out.println(\"threadC 开始调用 resourceA的notify()方法\"); resourceA.notify(); } }); // 启动线程 threadA.start(); threadB.start(); Thread.sleep(1000); threadC.start(); // 等待线程执行结束 threadA.join(); threadB.join(); threadC.join(); System.out.println(\"end---------------------\"); }} 如上代码开启了三个线程，其中A,B线程分别调用了resourceA的wait()方法，线程C在主线程休眠1s后调用了notify()方法。主线程休息1s是为了保证让线程A,B全部执行完wait()方法后再调用线程C的notify()方法。 这个例子试图再线程A和线程B都因调用共享资源resourceA的wait()方法而被阻塞后，让线程C调用resourceA的notify()方法，从而唤醒线程A,B。但是从执行结果来看，只有一个线程A被唤醒，线程B依然在阻塞挂起状态。 从输出结果可知线程调度器这次先调度了线程A占用Cpu来运行，线程A先获取到resourceA的资源所，然后调用wait()方法阻塞挂起，释放锁，而后线程B获取到资源锁，调用resourceA的wait()阻塞挂起。然后线程C调用notify()方法，尝试唤醒线程，这回激活resourceA的阻塞集合里面的一个线程，这里激活了线程A，所以线程A方法执行完毕并返回了。线程B则继续在阻塞等待中。如果把notify()方法换成notifyAll()结果会这样。 换成notifyAll()方法后，可以看到都得到了唤醒。因为上边也说过了notifyAll()方法会唤醒共享变量内所有的等待线程。这里就是唤醒了resourceA的等待集合里所有线程。只是线程B先抢到了resourceA上的锁，然后返回。然后线程A抢到也进行了返回。 尝试把主线程里面的休眠1s去掉，看一下执行结果。 线程B没有正常被唤醒。 这是因为线程C可能比线程B先执行了。如果调用notifyAll()方法后一个线程调用了该共享变量的wait()方法而被放到阻塞集合，则该线程不会被唤醒的，指挥唤醒执行notifyAll()方法前阻塞集合里的所有线程。 对wait(),notify(),notifyAll()的说明结束了 喜欢关注公众号:","link":"/detail/44.html"}],"tags":[{"name":"AQS","slug":"AQS","link":"/tags/AQS/"},{"name":"atomic","slug":"atomic","link":"/tags/atomic/"},{"name":"threadLocal","slug":"threadLocal","link":"/tags/threadLocal/"},{"name":"countDownLatch","slug":"countDownLatch","link":"/tags/countDownLatch/"},{"name":"LockSupport","slug":"LockSupport","link":"/tags/LockSupport/"},{"name":"LongAdder","slug":"LongAdder","link":"/tags/LongAdder/"},{"name":"ThreadLocal","slug":"ThreadLocal","link":"/tags/ThreadLocal/"},{"name":"读写锁","slug":"读写锁","link":"/tags/%E8%AF%BB%E5%86%99%E9%94%81/"},{"name":"volatile","slug":"volatile","link":"/tags/volatile/"},{"name":"线程通知与等待","slug":"线程通知与等待","link":"/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E7%9F%A5%E4%B8%8E%E7%AD%89%E5%BE%85/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"},{"name":"线程安全","slug":"java/线程安全","link":"/categories/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"},{"name":"ThreadLocal","slug":"java/ThreadLocal","link":"/categories/java/ThreadLocal/"},{"name":"Lock之读写锁","slug":"java/线程安全/Lock之读写锁","link":"/categories/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/Lock%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/"},{"name":"线程控制","slug":"java/线程安全/线程控制","link":"/categories/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"name":"volatile关键字","slug":"java/线程安全/volatile关键字","link":"/categories/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"AQS锁","slug":"java/线程安全/AQS锁","link":"/categories/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/AQS%E9%94%81/"},{"name":"线程通知与等待","slug":"java/线程通知与等待","link":"/categories/java/%E7%BA%BF%E7%A8%8B%E9%80%9A%E7%9F%A5%E4%B8%8E%E7%AD%89%E5%BE%85/"},{"name":"锁-LockSupport工具类","slug":"java/线程安全/锁-LockSupport工具类","link":"/categories/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/%E9%94%81-LockSupport%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"原子类LongAdder","slug":"java/线程安全/原子类LongAdder","link":"/categories/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/%E5%8E%9F%E5%AD%90%E7%B1%BBLongAdder/"},{"name":"原子类Atomic","slug":"java/线程安全/原子类Atomic","link":"/categories/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/%E5%8E%9F%E5%AD%90%E7%B1%BBAtomic/"},{"name":"原子类LongAccumulator","slug":"java/线程安全/原子类LongAccumulator","link":"/categories/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/%E5%8E%9F%E5%AD%90%E7%B1%BBLongAccumulator/"}]}