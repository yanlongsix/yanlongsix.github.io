<!doctype html>
<html lang="zh"><script src="/js/src/click.js"></script><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>AQS(上) 同步队列AQS介绍篇 - YanL&#039;s Blog</title><meta description="AQS——锁的底层支持AbstractQueuedSynchronizer抽象同步队列简称AQS，它是实现同步器的基础组件，并发包中锁的底层就是使用AQS实现的。另外，大多数开发者可能永远不会直接使用AQS，但是知道其原理对于架构设计还是很有帮助的。下面看下AQS的类图结构，如图所示。  由该图可以看到，AQS是一个FIFO的双向队列，其内部通过节点head和tail记录队首和队尾元素，队列元素的"><meta property="og:type" content="blog"><meta property="og:title" content="AQS(上) 同步队列AQS介绍篇"><meta property="og:url" content="https://www.doobird.cn/detail/52.html"><meta property="og:site_name" content="YanL&#039;s Blog"><meta property="og:description" content="AQS——锁的底层支持AbstractQueuedSynchronizer抽象同步队列简称AQS，它是实现同步器的基础组件，并发包中锁的底层就是使用AQS实现的。另外，大多数开发者可能永远不会直接使用AQS，但是知道其原理对于架构设计还是很有帮助的。下面看下AQS的类图结构，如图所示。  由该图可以看到，AQS是一个FIFO的双向队列，其内部通过节点head和tail记录队首和队尾元素，队列元素的"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://images.doobird.cn/upload/2020/04/0n1o659rimjm10n1o659rimjm1.png"><meta property="og:image" content="https://images.doobird.cn/upload/2020/04/04utjvu86kjr404utjvu86kjr4.png"><meta property="og:image" content="https://images.doobird.cn/blog/gongzhong_qrcode20490797-0487004de30329d5.jpg"><meta property="article:published_time" content="2020-04-23T16:10:27.000Z"><meta property="article:modified_time" content="2020-05-03T06:00:47.305Z"><meta property="article:author" content="John Doe"><meta property="article:tag" content="AQS"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://images.doobird.cn/upload/2020/04/0n1o659rimjm10n1o659rimjm1.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.doobird.cn/detail/52.html"},"headline":"YanL's Blog","image":["https://images.doobird.cn/upload/2020/04/0n1o659rimjm10n1o659rimjm1.png","https://images.doobird.cn/upload/2020/04/04utjvu86kjr404utjvu86kjr4.png","https://images.doobird.cn/blog/gongzhong_qrcode20490797-0487004de30329d5.jpg"],"datePublished":"2020-04-23T16:10:27.000Z","dateModified":"2020-05-03T06:00:47.305Z","author":{"@type":"Person","name":"John Doe"},"description":"AQS——锁的底层支持AbstractQueuedSynchronizer抽象同步队列简称AQS，它是实现同步器的基础组件，并发包中锁的底层就是使用AQS实现的。另外，大多数开发者可能永远不会直接使用AQS，但是知道其原理对于架构设计还是很有帮助的。下面看下AQS的类图结构，如图所示。  由该图可以看到，AQS是一个FIFO的双向队列，其内部通过节点head和tail记录队首和队尾元素，队列元素的"}</script><link rel="canonical" href="https://www.doobird.cn/detail/52.html"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">YanL&#039;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/yanlongsix"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-23T16:10:27.000Z" title="2020-04-23T16:10:27.000Z">2020-04-24</time><span class="level-item"><a class="link-muted" href="/categories/java/">java</a><span> / </span><a class="link-muted" href="/categories/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a><span> / </span><a class="link-muted" href="/categories/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/AQS%E9%94%81/">AQS锁</a></span><span class="level-item">21 分钟 读完 (大约 3104 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">AQS(上) 同步队列AQS介绍篇</h1><div class="content"><h4 id="AQS——锁的底层支持"><a href="#AQS——锁的底层支持" class="headerlink" title="AQS——锁的底层支持"></a>AQS——锁的底层支持</h4><p>AbstractQueuedSynchronizer抽象同步队列简称AQS，它是实现同步器的基础组件，并发包中锁的底层就是使用AQS实现的。另外，大多数开发者可能永远不会直接使用AQS，但是知道其原理对于架构设计还是很有帮助的。下面看下AQS的类图结构，如图所示。</p>
<p><img src="https://images.doobird.cn/upload/2020/04/0n1o659rimjm10n1o659rimjm1.png" alt="image-20200420175900001.png"></p>
<p>由该图可以看到，AQS是一个<strong>FIFO</strong>的双向队列，其内部通过节点<strong>head</strong>和<strong>tail</strong>记录队首和队尾元素，队列元素的类型为<strong>Node</strong>。</p>
<a id="more"></a>

<p><strong>Node节点内部参数介绍:</strong></p>
<ul>
<li><p>thread变量用来存放进入AQS队列里面的线程。</p>
</li>
<li><p>SHARED用来标记该线程是获取资源时被阻塞挂起后放入AQS队列的。</p>
</li>
<li><p>EXCLUSIVE用来标记线程是获取独占资源时被挂起后放入AQS队列的。</p>
</li>
<li><p>waitStatus记录当前线程等待状态，可以为以下几种:</p>
<p><strong>CANCELLED</strong>(线程被取消了)</p>
<p><strong>SIGNAL</strong>(线程需要被唤醒)</p>
<p><strong>CONDITION</strong>(线程在条件队列里面等待)</p>
<p><strong>PROPAGATE</strong>(释放共享资源时需要通知其他节点)</p>
</li>
<li><p>prev记录当前节点的前驱节点。</p>
</li>
<li><p>next记录节点的后继节点。</p>
</li>
</ul>
<p>在AQS中维持了一个单一状态的信息<strong>state</strong>，可以通过getState、setState、compareAndSetState函数修改其值。其具体哪些类中用到了我们可以看一下。</p>
<ul>
<li>对于ReentrantLock的实现来说，state可以用来表示当前线程获取锁的可重入次数。</li>
<li>对于读写锁ReentrantReadWriteLock来说，state的高16位表示读状态，也就是获取该读锁的次数，低16位标识获取到写锁的线程的可重入次数。</li>
<li>对于semaphore来说，state用来表示当前可用信号的个数。</li>
<li>对于CountDownlatch来说，state用来表示计数器当前的值。</li>
</ul>
<p>AQS有个内部类ConditionObject，用来结合锁实现线程同步。ConditionObject可以直接访问AQS对象内部的变量，比如state状态值和AQS队列。ConditionObject是条件变量，每个条件变量对应一个条件队列(单向链表队列)，其用来存放调用条件变量的await方法后被阻塞的线程，如类图所示，这个条件队列的头，尾元素分别为firstWaiter和lastWaiter。</p>
<p>对于AQS来说，线程同步的关键是对状态值state进行操作。根据state是否属于一个线程，操作state的方式分为独占方式和共享方式。</p>
<ul>
<li><p><strong>在独占方式下获取和释放资源使用的方法为：</strong></p>
<p>void acquire(int arg) </p>
<p>void acquireInterruptibly(int art)</p>
<p>boolean release(int arg)</p>
</li>
<li><p><strong>在共享方式下获取和释放资源的方法为:</strong></p>
<p>void acquireShared(int arg)</p>
<p>void acquireSharedInterruptibly(int arg)</p>
<p>boolean releaseShared(int arg)</p>
</li>
</ul>
<p>使用独占锁方式获取的资源是与具体线程绑定的，就是说如果一个线程获取到了资源，就会标记是这个线程获取到了，其他线程再尝试操作state获取资源时会发现当前该资源不是自己持有的，就会在获取失败后被阻塞。比如独占锁ReentrantLock的实现，当一个线程获取了ReentrantLock的锁后，在AQS内部会首先使用CAS操作把state状态值从0变为1，然后设置当前锁的持有者为当前线程，当该线程再次获取锁时会发现它就是锁的持有者，则会把状态从1变为2，也就是设置可重入次数，而当另一个线程获取锁时发现不是该锁的持有者就会被放入AQS阻塞队列后挂起。</p>
<p>对应共享方式的资源与具体线程是不相关的，当多个线程去请求资源时通过CAS方式竞争获取资源，当一个线程获取到资源后，另外一个线程再次去获取时如果当前资源还能满足它的需要，则当前线程只需要使用CAS方式获取即可。比如Semaphore信号量，当一个线程通过acquire()方法获取信号量时，会首先看当前信号量个数是否满足需求，不满足则把当前线程放入阻塞队列，如果满足则通过自旋CAS获取信号量。</p>
<p><strong>在独占方式下，获取与释放资源的流程如下：</strong></p>
<ol>
<li><p>当一个线程调用acquire(int arg)方法时，会首先使用tryAcquire方法尝试获取资源，具体是设置状态变量state的值，成功则直接返回，失败则将当前线程封装为类型Node.EXCLUSIVE的Node节点后插入到AQS阻塞队列的尾部，并调用LockSupport.park(this)方法挂起自己。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">		acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">		selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个线程调用release(int arg)方法时会尝试使用tryRelease操作释放资源，这里是设置状态变量state的值，然后调用LockSupport.unpark(thread)方法激活AQS队列里面被阻塞的一个线程(thread)。被激活的线程则使用tryAcquire尝试，看当前状态变量state的值是否能满足自己的需求，满足则该线程被激活，然后继续向下运行，否则还是会被入AQS队列被挂起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">     Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>需要注意的是，AQS类并没有提供可用的tryAcquire和tryRelease方法，正如AQS是锁阻塞和同步器的基础框架一样，tryAcquire和tryRelease需要由具体的子类来实现。子类在实现tryAcquire和tryRelease时需要根据场景使用CAS算法尝试修改state状态值，成功则返回true。子类还需要定义，在调用acquire和release方法时state状态值的增减代表什么含义。</p>
<p>比如继承自AQS实现的独占锁ReetrantLock，定义当status为0时表示锁空闲，为1表示锁已经被占用。再重写tryAcquire时，在内部需要使用CAS算法查看当前state是否为0，如果为0则使用CAS设置为1，并设置当前锁的持有者为当前线程，而后返回true，如果CAS失败则返回false。</p>
<p><strong>在共享方式下，获取与释放资源的流程如下:</strong></p>
<ol>
<li><p>当线程调用acquireShared(int arg)获取共享资源时，会首先使用 trγAcquireShared 尝试获取资源， 具体是设置状态变量 state 的值，成功则直接返回，失败则将当前线 程封装为类型为 Node.SHARED 的 Node 节点后插入到 AQS 阻塞 队列的尾部，并使用 LockSupport.park(this)方法挂起自己。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个线程调用 releaseShared(int arg)时会尝试使用 tryReleaseShared 操作释放资源，这里是设置状态变量state 的值，然后使用 LockSupport.unpark (thread）激活 AQS 队 列里面被阻塞的一个线程 (thread)。被激活的线程则使用 tryReleaseShared 查看当前状态变 量 state 的值是否能满足自己的需要，满足则该线程被撤活，然后继续向下运行，否则还 是会被放入 AQS 队列并被挂起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>同样需要注意的是， AQS 类并没有提供可用的 t可AcquireShared 和 tryRelease Shared 方法，正如 AQS 是锁阻塞和同步器的基础框架一样，tryAcquireShared 和 tryReleaseShared 需要由具体的子类来实现。子类在实现 tryAcquireShared 和 tryReleaseShared 时要根据具体 场景使用CAS算法尝试修改 state 状态值，成功则返回 true否则返回 false。</p>
<p>比如继承自 AQS 实现的读写锁 ReentrantReadWriteLock 里面的读锁在重写 tryAcquireShared 时，首先查看写锁是否被其他线程持有，如果是则直接返回 false，否则使用 CAS 递增 state 的高16位 (在 ReentrantReadWriteLock 中，state 的 高 16 位为获取读锁的次数)。</p>
<p>比如继 承自 AQS 实现 的 读写也Ji ReentrantReadWriteLock 里面的 读锁在重写 t叩ReleaseShared 时，在内部需要使用 CAS 算法把当前 state 值的高 16 位减 1， 然后返回 true，如果 CAS 失败则返回 false。</p>
<p>基于 AQS 实现的锁除了 需要重写上面介绍的方法外，还需要重写 isHeldExclusively 方法，来判断锁是被当前线程独占还是被共享。</p>
<p>另外， 也许你会好奇，独占方式下的 void acquire(int arg）和void acquirelnterruptibly(int arg），与共享方式下的 void acquireShared(int arg）和 void acquireSharedlnterruptibly(int arg), 这两套函数中都有一个带有 Interruptibly 关键字的函数，那么带这个关键字和不带有什么 区别呢？我们来讲讲。</p>
<p>其实不带 Intenuptibly 关键字的方法的意思是不对中断进行响应，也就是线程在调用 不带 Interruptibly 关键字的方法获取资源时或者获取资源失败被挂起时，其他线程中断了 该线程， 那么该线程不会因为被中断而抛出异常，它还是继续获取资源或者被挂起，也就 是说不对中断进行响应，忽略中断。</p>
<p>而带 Interruptibly 关键字的方法要对中断进行l响应，也就是线程在调用带 Interruptibly 关键字的方法获取资源时或者获取资源失败被挂起时，其他线程中断了该线程，那么该线 程会抛出 InterruptedException 异常而返回。</p>
<p>最后，我们来看看如何维护 AQS 提供的队列，主要看入队操作。</p>
<p>入队操作： 当一个线程获取锁失败后该线程会被转换为 Node 节点，然后就会使用 enq(final Node node)方法将该节点插入到 AQS 的阻塞队列。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail; <span class="comment">// （1）</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">// （2）</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t; <span class="comment">// （3）</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">// （4）</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面结合代码和节点图(下方图)来讲解入队的过程。 如上代码在第一次循环中， 当要在 AQS 队列尾部插入元素时， AQS 队列状态如下方图中（default）所示。 也就是队列 头、尾节点都指向 null ； 当执行代码 (1 ）后节点 t 指向了尾部节点，这时候队列状态如下方图 中 (I）所示。</p>
<p>这时候 t 为 null ，故执行代码（2 ），使用 CAS 算法设置一个哨兵节点为头节点，如果 CAS 设置成功，则让尾部节点也指向哨兵节点，这时候队列状态如下方图中（II）所示。</p>
<p>到现在为止只插入了一个哨兵节点，还需要插入 node 节点，所以在第二次循环后执 行到代码 (1 ），这时候队列状态如下方图 (III）所示 ； 然后执行代码 (3 ）设置 node 的 前驱节点为尾部节点，这时候队列状态如下方图 中 (IV）所示：然后通过 CAS 算法设置 node 节点为尾部节点， CAS 成功后队列状态如下方图 中 CV ）所示： CAS 成功后再设置原 来的尾部节点的后驱节点为 node 这时候就完成了双向链表的插入，此时队列状态如下方图 中（ VI) 所示。</p>
<p><img src="https://images.doobird.cn/upload/2020/04/04utjvu86kjr404utjvu86kjr4.png" alt="image-20200423235313934.png"></p>
<p><strong>到这里AQS概述，就结束了，下节说条件变量的支持！</strong></p>
<p><strong>喜欢关注公众号:</strong></p>
<p><img src="https://images.doobird.cn/blog/gongzhong_qrcode20490797-0487004de30329d5.jpg" alt="qrcode"></p>
<p>我的博客即将同步至腾讯云+社区，邀请大家一同入驻：<br><a href="https://cloud.tencent.com/developer/support-plan?invite_code=33ptblcpxsis8">https://cloud.tencent.com/developer/support-plan?invite_code=33ptblcpxsis8</a></p>
</div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/AQS/">AQS</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://images.doobird.cn/blog/gongzhong_qrcode20490797-0487004de30329d5.jpg" alt="支付宝"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://images.doobird.cn/blog/gongzhong_qrcode20490797-0487004de30329d5.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/detail/51.html"><span class="level-item">LockSupport 工具类使用以及实现原理</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-3-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="https://qiniu.gaobinzhan.com/2019/12/18/e5818380cbc1a.jpg" alt="YanL"></figure><p class="title is-size-4 is-block line-height-inherit">YanL</p><p class="is-size-6 is-block">精神小伙不请自来</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">10</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/12/"><span class="level-start"><span class="level-item">十二月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">YanL&#039;s Blog</a><a>豫ICP备19040445号</a><p class="size-small"><span>&copy; 2020 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external nofollow">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow" title="Download on GitHub" href="https://github.com/yanlongsix"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://www.doobird.cn',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>